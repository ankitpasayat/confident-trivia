#!/usr/bin/env tsx
/**
 * Script to analyze the distribution of question types generated by AI
 * 
 * Usage:
 *   npm run analyze-questions              (3 batches, no question details)
 *   npm run analyze-questions -- --show    (10 batches, show all questions)
 *   npm run analyze-questions -- --once    (1 batch, show questions)
 *   npm run analyze-questions -- --batches 5  (5 batches)
 */

// Load environment variables FIRST before any other imports
import { config } from 'dotenv';
config({ path: '.env.local' });
config({ path: '.env' });

import { generateQuestionsWithGemini } from '../lib/gemini-question-generator';
import { generateQuestionsWithOpenAI } from '../lib/openai-question-generator';

// Parse command line arguments
const args = process.argv.slice(2);
const showQuestions = args.includes('--show') || args.includes('--once');
const onceMode = args.includes('--once');
const batchesIndex = args.indexOf('--batches');
const customBatches = batchesIndex !== -1 ? parseInt(args[batchesIndex + 1]) : null;

const SAMPLE_SIZE = onceMode ? 1 : (customBatches || 3);
const QUESTIONS_PER_BATCH = 10; // Questions per batch

interface Distribution {
  'multiple-choice': number;
  'true-false': number;
  'more-or-less': number;
  'numerical': number;
}

async function analyzeDistribution(
  generator: 'gemini' | 'openai'
): Promise<void> {
  const distribution: Distribution = {
    'multiple-choice': 0,
    'true-false': 0,
    'more-or-less': 0,
    'numerical': 0,
  };

  let totalQuestions = 0;
  let failedBatches = 0;

  const generatorName = generator === 'gemini' ? 'Gemini' : 'OpenAI';
  console.log(`\n${'='.repeat(60)}`);
  console.log(`Analyzing ${generatorName} Question Distribution`);
  console.log(`${'='.repeat(60)}`);
  console.log(`Generating ${QUESTIONS_PER_BATCH} questions, ${SAMPLE_SIZE} times...\n`);

  const startTime = Date.now();

  // Generate questions multiple times
  for (let i = 0; i < SAMPLE_SIZE; i++) {
    try {
      const questions =
        generator === 'gemini'
          ? await generateQuestionsWithGemini({ count: QUESTIONS_PER_BATCH })
          : await generateQuestionsWithOpenAI({ count: QUESTIONS_PER_BATCH });

      // Count question types
      const batchDist: Distribution = {
        'multiple-choice': 0,
        'true-false': 0,
        'more-or-less': 0,
        'numerical': 0,
      };

      for (const q of questions) {
        if (q.type in distribution) {
          distribution[q.type as keyof Distribution]++;
          batchDist[q.type as keyof Distribution]++;
          totalQuestions++;
        }
      }

      // Print the actual questions if requested
      if (showQuestions) {
        console.log('\n' + '‚îÄ'.repeat(60));
        console.log('Generated Questions:');
        console.log('‚îÄ'.repeat(60));
        questions.forEach((q, idx) => {
          console.log(`\n${idx + 1}. [${q.type.toUpperCase()}] ${q.text}`);
          if (q.type === 'multiple-choice' && q.options) {
            q.options.forEach((opt, i) => console.log(`   ${String.fromCharCode(65 + i)}. ${opt}`));
            console.log(`   ‚úì Answer: ${String.fromCharCode(65 + (q.correctAnswer as number))}`);
          } else if (q.type === 'true-false') {
            console.log(`   ‚úì Answer: ${q.correctAnswer ? 'TRUE' : 'FALSE'}`);
          } else if (q.type === 'more-or-less') {
            console.log(`   A. ${q.option1}`);
            console.log(`   B. ${q.option2}`);
            console.log(`   ‚úì Answer: ${q.correctAnswer === 0 ? 'A' : 'B'} (${q.correctAnswer === 0 ? q.option1 : q.option2})`);
          } else if (q.type === 'numerical') {
            console.log(`   ‚úì Answer: ${q.correctAnswer}${q.unit || ''}`);
          }
        });
        console.log('\n' + '‚îÄ'.repeat(60) + '\n');
      }

      const progress = ((i + 1) / SAMPLE_SIZE) * 100;
      console.log(
        `[${progress.toFixed(0).padStart(3)}%] Batch ${(i + 1).toString().padStart(2)}/${SAMPLE_SIZE}: ` +
        `MC=${batchDist['multiple-choice'].toString().padStart(2)} ` +
        `TF=${batchDist['true-false'].toString().padStart(2)} ` +
        `MOL=${batchDist['more-or-less'].toString().padStart(2)} ` +
        `NUM=${batchDist['numerical'].toString().padStart(2)}`
      );
    } catch (error) {
      failedBatches++;
      console.error(`‚úó Batch ${i + 1} failed:`, error instanceof Error ? error.message : error);
    }

    // Add delay to avoid rate limiting (except on last iteration)
    if (i < SAMPLE_SIZE - 1) {
      await new Promise(resolve => setTimeout(resolve, 1500));
    }
  }

  const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);

  if (totalQuestions === 0) {
    console.error('\n‚ùå No questions were generated successfully!');
    return;
  }

  // Calculate percentages
  const percentages = {
    'multiple-choice': ((distribution['multiple-choice'] / totalQuestions) * 100).toFixed(1),
    'true-false': ((distribution['true-false'] / totalQuestions) * 100).toFixed(1),
    'more-or-less': ((distribution['more-or-less'] / totalQuestions) * 100).toFixed(1),
    'numerical': ((distribution['numerical'] / totalQuestions) * 100).toFixed(1),
  };

  // Target distribution
  const targets = {
    'multiple-choice': 40,
    'true-false': 25,
    'more-or-less': 30,
    'numerical': 5,
  };

  // Print results
  console.log(`\n${'='.repeat(60)}`);
  console.log('RESULTS');
  console.log(`${'='.repeat(60)}`);
  console.log(`Total questions: ${totalQuestions}`);
  console.log(`Failed batches: ${failedBatches}`);
  console.log(`Time elapsed: ${elapsedTime}s`);

  console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
  console.log('‚îÇ Question Type   ‚îÇ Count  ‚îÇ Actual % ‚îÇ Target % ‚îÇ Deviation  ‚îÇ');
  console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
  
  Object.keys(distribution).forEach(type => {
    const key = type as keyof Distribution;
    const count = distribution[key].toString().padStart(6);
    const actual = percentages[key].padStart(7) + '%';
    const target = targets[key].toString().padStart(7) + '%';
    const deviation = (parseFloat(percentages[key]) - targets[key]).toFixed(1);
    const deviationStr = (deviation.startsWith('-') ? '' : '+') + deviation + '%';
    const deviationPadded = deviationStr.padStart(10);
    
    // Highlight if deviation is significant
    const isSignificant = Math.abs(parseFloat(deviation)) > 10;
    const prefix = isSignificant ? '‚îÇ ‚ö†Ô∏è  ' : '‚îÇ ';
    
    console.log(`${prefix}${type.padEnd(14)} ‚îÇ${count} ‚îÇ${actual} ‚îÇ${target} ‚îÇ${deviationPadded} ‚îÇ`);
  });
  
  console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

  // Analysis
  console.log('\n' + '='.repeat(60));
  console.log('ANALYSIS');
  console.log('='.repeat(60));

  const mcPercentage = parseFloat(percentages['multiple-choice']);
  const tfPercentage = parseFloat(percentages['true-false']);
  const molPercentage = parseFloat(percentages['more-or-less']);
  const numPercentage = parseFloat(percentages['numerical']);

  let hasIssues = false;

  // Check Multiple Choice (target: 40%, range: 30-50%)
  if (mcPercentage < 30) {
    console.log('‚ùå Multiple-choice questions are SIGNIFICANTLY underrepresented!');
    console.log(`   Expected: 40%, Got: ${mcPercentage}%`);
    hasIssues = true;
  } else if (mcPercentage > 50) {
    console.log('‚ùå Multiple-choice questions are DOMINATING!');
    console.log(`   Expected: 40%, Got: ${mcPercentage}%`);
    hasIssues = true;
  } else if (mcPercentage < 35 || mcPercentage > 45) {
    console.log('‚ö†Ô∏è  Multiple-choice questions deviate from target.');
    console.log(`   Expected: 40%, Got: ${mcPercentage}%`);
  } else {
    console.log('‚úÖ Multiple-choice distribution looks good!');
    console.log(`   Expected: 40%, Got: ${mcPercentage}%`);
  }

  // Check True/False (target: 25%, range: 15-35%)
  if (tfPercentage < 15) {
    console.log('\n‚ùå True-false questions are SIGNIFICANTLY underrepresented!');
    console.log(`   Expected: 25%, Got: ${tfPercentage}%`);
    hasIssues = true;
  } else if (tfPercentage > 35) {
    console.log('\n‚ùå True-false questions are OVER-REPRESENTED!');
    console.log(`   Expected: 25%, Got: ${tfPercentage}%`);
    hasIssues = true;
  } else if (tfPercentage < 20 || tfPercentage > 30) {
    console.log('\n‚ö†Ô∏è  True-false questions deviate from target.');
    console.log(`   Expected: 25%, Got: ${tfPercentage}%`);
  } else {
    console.log('\n‚úÖ True-false distribution looks good!');
    console.log(`   Expected: 25%, Got: ${tfPercentage}%`);
  }

  // Check More-or-Less (target: 30%, range: 20-40%)
  if (molPercentage < 20) {
    console.log('\n‚ùå More-or-less questions are SIGNIFICANTLY underrepresented!');
    console.log(`   Expected: 30%, Got: ${molPercentage}%`);
    console.log(`   Missing: ~${((30 - molPercentage) / 100 * totalQuestions).toFixed(0)} more-or-less questions`);
    hasIssues = true;
  } else if (molPercentage > 40) {
    console.log('\n‚ùå More-or-less questions are OVER-REPRESENTED!');
    console.log(`   Expected: 30%, Got: ${molPercentage}%`);
    hasIssues = true;
  } else if (molPercentage < 25 || molPercentage > 35) {
    console.log('\n‚ö†Ô∏è  More-or-less questions deviate from target.');
    console.log(`   Expected: 30%, Got: ${molPercentage}%`);
  } else {
    console.log('\n‚úÖ More-or-less distribution looks good!');
    console.log(`   Expected: 30%, Got: ${molPercentage}%`);
  }

  // Check Numerical (target: 5%, range: 0-15%)
  if (numPercentage > 15) {
    console.log('\n‚ùå Numerical questions are OVER-REPRESENTED!');
    console.log(`   Expected: 5%, Got: ${numPercentage}%`);
    hasIssues = true;
  } else if (numPercentage > 10) {
    console.log('\n‚ö†Ô∏è  Numerical questions are somewhat over-represented.');
    console.log(`   Expected: 5%, Got: ${numPercentage}%`);
  } else {
    console.log('\n‚úÖ Numerical distribution looks good!');
    console.log(`   Expected: 5%, Got: ${numPercentage}%`);
  }

  if (!hasIssues) {
    console.log('\nüéâ Overall distribution is within acceptable ranges!');
  }

  console.log('\n' + '='.repeat(60) + '\n');
}

async function main() {
  const hasGeminiKey = !!process.env.GOOGLE_API_KEY;
  const hasOpenAIKey = !!process.env.OPENAI_API_KEY;

  console.log('Question Distribution Analysis Tool');
  console.log('===================================\n');
  console.log('API Keys Status:');
  console.log(`  Gemini: ${hasGeminiKey ? '‚úì Set' : '‚úó Not set'}`);
  console.log(`  OpenAI: ${hasOpenAIKey ? '‚úì Set' : '‚úó Not set'}`);

  if (!hasGeminiKey && !hasOpenAIKey) {
    console.error('\n‚ùå Error: No API keys found!');
    console.error('   Set GOOGLE_API_KEY or OPENAI_API_KEY environment variable.');
    console.error('\n   Example:');
    console.error('   export GOOGLE_API_KEY=your_key_here');
    console.error('   npx tsx scripts/analyze-question-distribution.ts');
    process.exit(1);
  }

  // Determine which generator to use
  const generator = hasGeminiKey ? 'gemini' : 'openai';
  
  try {
    await analyzeDistribution(generator);
  } catch (error) {
    console.error('\n‚ùå Analysis failed:', error);
    process.exit(1);
  }
}

main();
